#!/usr/bin/env python3
"""
Teste automatizado que simula clique no bot√£o 'Novo Chat' do Mesop UI
Verifica cria√ß√£o correta de ChatSession e valida√ß√£o de tipos
"""

import sys
import os
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass, field, is_dataclass, asdict
from typing import Dict, List, Any
import json
import uuid

# Adicionar o diret√≥rio backend ao path
backend_dir = Path(__file__).parent.parent
sys.path.insert(0, str(backend_dir))

# Mock do Mesop antes de importar o app
class MockClickEvent:
    """Mock do me.ClickEvent"""
    def __init__(self):
        self.key = "mock_click"
        self.value = None

class MockState:
    """Mock para me.state()"""
    _instance = None
    
    def __init__(self, state_class):
        if MockState._instance is None:
            MockState._instance = state_class()
        return MockState._instance

# Mock do m√≥dulo mesop
class MockMesop:
    @staticmethod
    def state(state_class):
        """Retorna inst√¢ncia do estado"""
        if not hasattr(MockMesop, '_state_instance'):
            MockMesop._state_instance = state_class()
        return MockMesop._state_instance
    
    @staticmethod
    def stateclass(cls):
        """Decorator mock para stateclass"""
        return dataclass(cls)
    
    class ClickEvent:
        def __init__(self):
            self.key = "mock_click"

# Substituir importa√ß√£o do mesop
sys.modules['mesop'] = MockMesop()
sys.modules['mesop.labs'] = MockMesop()
me = MockMesop()

# Agora importar as classes do app
from app import (
    ChatSession, 
    Message, 
    State,
    create_new_session,
    ensure_chatsession,
    normalize_sessions,
    save_session,
    handle_new_chat
)

def test_new_chat_button_click():
    """Testa o comportamento completo do clique no bot√£o Novo Chat"""
    
    print("\nüß™ TESTE: Simula√ß√£o de clique no bot√£o 'Novo Chat'")
    print("=" * 60)
    
    # 1. Configurar estado inicial
    print("\n1Ô∏è‚É£ Configurando estado inicial...")
    MockMesop._state_instance = State()
    state = MockMesop.state(State)
    
    # Criar sess√£o inicial
    initial_session = create_new_session("Sess√£o Inicial")
    state.sessions[initial_session.id] = initial_session
    state.current_session = initial_session
    
    # Adicionar uma mensagem √† sess√£o inicial
    initial_message = Message(
        content="Mensagem de teste",
        role="user"
    )
    state.current_session.messages.append(initial_message)
    
    print(f"   ‚úÖ Estado inicial criado com {len(state.sessions)} sess√£o")
    print(f"   ‚úÖ Sess√£o atual: {state.current_session.title}")
    print(f"   ‚úÖ Mensagens na sess√£o: {len(state.current_session.messages)}")
    
    # 2. Verificar tipos antes do clique
    print("\n2Ô∏è‚É£ Verificando tipos antes do clique...")
    assert isinstance(state.current_session, ChatSession), "current_session deve ser ChatSession"
    assert is_dataclass(state.current_session), "current_session deve ser dataclass"
    
    for session_id, session in state.sessions.items():
        assert isinstance(session, ChatSession), f"Session {session_id} deve ser ChatSession"
        assert is_dataclass(session), f"Session {session_id} deve ser dataclass"
    
    print("   ‚úÖ Todos os tipos est√£o corretos antes do clique")
    
    # 3. Simular clique no bot√£o
    print("\n3Ô∏è‚É£ Simulando clique no bot√£o 'Novo Chat'...")
    initial_session_count = len(state.sessions)
    initial_session_id = state.current_session.id
    
    # Criar evento mock
    click_event = MockMesop.ClickEvent()
    
    # Executar handler
    handle_new_chat(click_event)
    
    print("   ‚úÖ Handler handle_new_chat executado")
    
    # 4. Verificar nova sess√£o criada
    print("\n4Ô∏è‚É£ Verificando nova sess√£o criada...")
    assert len(state.sessions) == initial_session_count + 1, "Deve ter uma nova sess√£o"
    assert state.current_session.id != initial_session_id, "current_session deve ser diferente"
    assert state.current_session.title == "Nova Conversa", "T√≠tulo deve ser 'Nova Conversa'"
    assert len(state.current_session.messages) == 0, "Nova sess√£o deve ter 0 mensagens"
    
    print(f"   ‚úÖ Nova sess√£o criada com ID: {state.current_session.id}")
    print(f"   ‚úÖ Total de sess√µes agora: {len(state.sessions)}")
    
    # 5. Verificar que √© dataclass, n√£o dict
    print("\n5Ô∏è‚É£ Verificando que nova sess√£o √© dataclass...")
    assert isinstance(state.current_session, ChatSession), "Nova sess√£o deve ser ChatSession"
    assert is_dataclass(state.current_session), "Nova sess√£o deve ser dataclass"
    assert not isinstance(state.current_session, dict), "Nova sess√£o N√ÉO deve ser dict"
    
    # Verificar no dicion√°rio tamb√©m
    saved_session = state.sessions[state.current_session.id]
    assert isinstance(saved_session, ChatSession), "Sess√£o salva deve ser ChatSession"
    assert is_dataclass(saved_session), "Sess√£o salva deve ser dataclass"
    
    print("   ‚úÖ Nova sess√£o √© dataclass corretamente")
    
    # 6. Verificar timestamps como ISO strings
    print("\n6Ô∏è‚É£ Verificando timestamps como ISO strings...")
    assert isinstance(state.current_session.created_at, str), "created_at deve ser string"
    assert isinstance(state.current_session.last_activity, str), "last_activity deve ser string"
    
    # Verificar formato ISO
    try:
        datetime.fromisoformat(state.current_session.created_at)
        datetime.fromisoformat(state.current_session.last_activity)
        print("   ‚úÖ Timestamps s√£o strings ISO v√°lidas")
    except ValueError as e:
        raise AssertionError(f"Timestamps n√£o est√£o em formato ISO: {e}")
    
    # 7. Verificar serializa√ß√£o JSON
    print("\n7Ô∏è‚É£ Verificando serializa√ß√£o JSON...")
    try:
        # Tentar serializar como o Mesop faria
        json_str = json.dumps(asdict(state.current_session))
        print(f"   ‚úÖ Sess√£o √© JSON serializ√°vel ({len(json_str)} bytes)")
        
        # Verificar todo o estado
        state_dict = asdict(state)
        json_str = json.dumps(state_dict)
        print(f"   ‚úÖ Estado completo √© JSON serializ√°vel ({len(json_str)} bytes)")
    except TypeError as e:
        raise AssertionError(f"Erro de serializa√ß√£o: {e}")
    
    # 8. Verificar que sess√£o anterior ainda existe
    print("\n8Ô∏è‚É£ Verificando que sess√£o anterior ainda existe...")
    assert initial_session_id in state.sessions, "Sess√£o inicial deve ainda existir"
    old_session = state.sessions[initial_session_id]
    assert len(old_session.messages) == 1, "Sess√£o antiga deve manter suas mensagens"
    
    print("   ‚úÖ Sess√£o anterior preservada corretamente")
    
    print("\n" + "=" * 60)
    print("üéâ SUCESSO! Todos os testes passaram!")
    print("‚úÖ O bot√£o 'Novo Chat' est√° funcionando corretamente")
    print("‚úÖ N√£o h√° problemas de dict vs dataclass")
    print("‚úÖ Serializa√ß√£o JSON funciona perfeitamente")
    
    return True

def test_multiple_new_chats():
    """Testa cria√ß√£o de m√∫ltiplas novas sess√µes em sequ√™ncia"""
    
    print("\nüß™ TESTE: M√∫ltiplos cliques no bot√£o 'Novo Chat'")
    print("=" * 60)
    
    # Resetar estado
    MockMesop._state_instance = State()
    state = MockMesop.state(State)
    
    # Criar v√°rias sess√µes
    session_ids = []
    for i in range(5):
        click_event = MockMesop.ClickEvent()
        handle_new_chat(click_event)
        session_ids.append(state.current_session.id)
        print(f"   ‚úÖ Sess√£o {i+1} criada: {state.current_session.id}")
    
    # Verificar que todas s√£o diferentes
    assert len(set(session_ids)) == 5, "Todas as sess√µes devem ter IDs √∫nicos"
    assert len(state.sessions) >= 5, "Deve ter pelo menos 5 sess√µes"
    
    # Verificar que todas s√£o dataclasses
    for session_id, session in state.sessions.items():
        assert is_dataclass(session), f"Session {session_id} deve ser dataclass"
        assert isinstance(session.created_at, str), f"Session {session_id} created_at deve ser string"
    
    print("\n‚úÖ M√∫ltiplas sess√µes criadas com sucesso!")
    return True

def test_error_prevention():
    """Testa que o erro 'asdict() should be called on dataclass instances' n√£o ocorre"""
    
    print("\nüß™ TESTE: Preven√ß√£o do erro de serializa√ß√£o")
    print("=" * 60)
    
    # Resetar estado
    MockMesop._state_instance = State()
    state = MockMesop.state(State)
    
    # Simular cen√°rio que causava erro
    print("\n1Ô∏è‚É£ Criando sess√£o com potencial para erro...")
    
    # Tentar for√ßar o problema antigo
    bad_session = {
        'id': 'test-id',
        'title': 'Test Session',
        'messages': [],
        'created_at': datetime.now(),  # datetime object - causaria erro!
        'last_activity': datetime.now()
    }
    
    # Nossa fun√ß√£o deve corrigir isso
    fixed_session = ensure_chatsession(bad_session)
    
    print("   ‚úÖ ensure_chatsession corrigiu o problema")
    
    # Verificar que foi corrigido
    assert isinstance(fixed_session.created_at, str), "created_at deve ser string ap√≥s corre√ß√£o"
    assert isinstance(fixed_session.last_activity, str), "last_activity deve ser string ap√≥s corre√ß√£o"
    
    # Tentar serializar
    try:
        json_str = json.dumps(asdict(fixed_session))
        print(f"   ‚úÖ Sess√£o corrigida √© serializ√°vel ({len(json_str)} bytes)")
    except TypeError as e:
        raise AssertionError(f"Corre√ß√£o falhou: {e}")
    
    print("\n‚úÖ Prote√ß√£o contra erro de serializa√ß√£o funcionando!")
    return True

if __name__ == "__main__":
    """Executar todos os testes"""
    
    print("\n" + "üöÄ" * 30)
    print("INICIANDO SUITE DE TESTES - BOT√ÉO 'NOVO CHAT' MESOP")
    print("üöÄ" * 30)
    
    tests_passed = 0
    tests_failed = 0
    
    tests = [
        test_new_chat_button_click,
        test_multiple_new_chats,
        test_error_prevention
    ]
    
    for test_func in tests:
        try:
            if test_func():
                tests_passed += 1
        except Exception as e:
            tests_failed += 1
            print(f"\n‚ùå FALHA em {test_func.__name__}: {e}")
            import traceback
            traceback.print_exc()
    
    print("\n" + "=" * 60)
    print(f"üìä RESULTADO FINAL:")
    print(f"   ‚úÖ Testes passados: {tests_passed}")
    print(f"   ‚ùå Testes falhados: {tests_failed}")
    
    if tests_failed == 0:
        print("\nüéä TODOS OS TESTES PASSARAM COM SUCESSO! üéä")
        print("O bot√£o 'Novo Chat' est√° funcionando perfeitamente!")
    else:
        print(f"\n‚ö†Ô∏è {tests_failed} teste(s) falharam. Verifique os erros acima.")
    
    sys.exit(0 if tests_failed == 0 else 1)